# JavaScript运行机制

## 单线程

JS作为浏览器脚本语言，主要用途是与用户交互、操作DOM。

假设JS多线程，一个线程在DOM节点添加内容，另一个线程删除这个节点，这样考虑复杂的同步问题。

为了利用多核CPU计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，子线程不得操作DOM。所以，新标准并没有改变JS单线程的本质。

## 任务队列

* 同步任务（synchronous）

主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务；

* 异步任务（asynchronous）

不进入主线程，而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

>> 异步运行机制

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

## 事件和回调函数

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

## Event Loop

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

<img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" width="400px"/>

上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。

执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行。请看下面这个例子。

```js
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.onload = function (){};
    req.onerror = function (){};
    req.send();
```

上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取"任务队列"。所以，它与下面的写法等价。

```js
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.send();
    req.onload = function (){};
    req.onerror = function (){};
```

也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取"任务队列"。